/*
 * Copyright Â© 2025 Technology Matters
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see https://www.gnu.org/licenses/.
 */

/**
 * Generated by Claude

 * Validates that i18n variable names in translation files match across all languages.
 * Variables are denoted by {{variableName}} in the JSON strings.

 * Output: 
 * Will print strings with mismatched variables as: 
 *   ----- language code -----
 *   "string.name": english_unmatched_vars <--> other_language_unmatched_vars
 */

import {readFile} from 'fs/promises';
import path from 'path';

import {filesInFolder} from './utils.mjs';
import {flatten} from 'flat';

const SOURCE_LOCALE = 'en';
const LOCALE_FILES_FOLDER = new URL('../../src/translations/', import.meta.url);

/**
 * Extracts all variable names from a string (e.g., "Hello {{name}}" -> ["name"])
 */
export function extractVariables(str) {
  const regex = /\{\{([^}]+)\}\}/g;
  const matches = [];
  let match;

  while ((match = regex.exec(str)) !== null) {
    matches.push(match[1]);
  }

  return matches;
}

/**
 * Compares variable names between two strings
 * Returns true if they have the exact same variable names (order doesn't matter)
 */
export function variablesMatch(vars1, vars2) {
  if (vars1.length !== vars2.length) {
    return false;
  }

  const sorted1 = [...vars1].sort();
  const sorted2 = [...vars2].sort();

  return sorted1.every((v, i) => v === sorted2[i]);
}

/**
 * Validates a translation file against the English reference
 */
export function validateTranslation(
  englishFlat,
  translationFlat,
  languageCode,
) {
  const mismatches = [];

  for (const [key, englishStr] of Object.entries(englishFlat)) {
    const translationStr = translationFlat[key];

    // Skip if the key doesn't exist in translation (that's a different validation)
    if (!translationStr) {
      continue;
    }

    const englishVars = extractVariables(englishStr);
    const translationVars = extractVariables(translationStr);

    // Only report if there's a mismatch
    if (!variablesMatch(englishVars, translationVars)) {
      mismatches.push({
        key,
        englishVars,
        translationVars,
      });
    }
  }

  return {
    language: languageCode,
    mismatches,
  };
}

/**
 * Formats a validation result for display
 */
export function formatValidationResult(result) {
  if (result.mismatches.length === 0) {
    return `----- ${result.language} -----\nNo mismatches found.`;
  }

  const lines = result.mismatches.map(mismatch => {
    const englishVars = mismatch.englishVars.map(v => `{{${v}}}`).join(', ');
    const translationVars = mismatch.translationVars
      .map(v => `{{${v}}}`)
      .join(', ');
    return `"${mismatch.key}": ${englishVars} <--> ${translationVars}`;
  });

  return `----- ${result.language} -----\n${lines.join('\n')}`;
}

/**
 * Main validation function
 */
const validateAllTranslations = async () => {
  // Read English reference file
  const englishContent = await readFile(
    new URL(`${SOURCE_LOCALE}.json`, LOCALE_FILES_FOLDER),
  );
  const englishJson = JSON.parse(englishContent);
  const englishFlat = flatten(englishJson);

  // Get all locale files
  const files = await filesInFolder(LOCALE_FILES_FOLDER);
  const localeFiles = files.filter(file => file.toString().endsWith('.json'));

  const results = [];

  // Process each locale file
  for (const filePath of localeFiles) {
    const languageCode = path.parse(filePath.pathname).name;

    // Skip the source locale
    if (languageCode === SOURCE_LOCALE) {
      continue;
    }

    const translationContent = await readFile(filePath);
    const translationJson = JSON.parse(translationContent);
    const translationFlat = flatten(translationJson);

    const result = validateTranslation(
      englishFlat,
      translationFlat,
      languageCode,
    );
    results.push(result);
  }

  // Print results
  let hasErrors = false;
  for (const result of results) {
    console.log(formatValidationResult(result));
    if (result.mismatches.length > 0) {
      hasErrors = true;
    }
    console.log(''); // Empty line between languages
  }

  // Exit with error code if mismatches found
  process.exit(hasErrors ? 1 : 0);
};

// Run if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  validateAllTranslations().catch(err => {
    console.error('Error validating translations:', err);
    process.exit(1);
  });
}
