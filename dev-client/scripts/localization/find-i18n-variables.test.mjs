/*
 * Copyright © 2025 Technology Matters
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see https://www.gnu.org/licenses/.
 */

// Generated by Claude

import {strict as assert} from 'assert';

import {
  extractVariables,
  formatValidationResult,
  validateTranslation,
  variablesMatch,
} from './validateI18nVariables.mjs';
import {flatten} from 'flat';

// Test extractVariables
function testExtractVariables() {
  console.log('Testing extractVariables...');

  // Test with no variables
  assert.deepEqual(extractVariables('Hello world'), []);

  // Test with one variable
  assert.deepEqual(extractVariables('Hello {{name}}'), ['name']);

  // Test with multiple variables
  assert.deepEqual(
    extractVariables('{{measurement}}{{units}} (in {{units}})'),
    ['measurement', 'units', 'units'],
  );

  // Test with variables at different positions
  assert.deepEqual(extractVariables('Start {{var1}} middle {{var2}} end'), [
    'var1',
    'var2',
  ]);

  // Test with no variables in complex string
  assert.deepEqual(extractVariables('Test {} value {{ incomplete'), []);

  console.log('✓ extractVariables tests passed');
}

// Test variablesMatch
function testVariablesMatch() {
  console.log('Testing variablesMatch...');

  // Test identical arrays
  assert.equal(variablesMatch(['name'], ['name']), true);

  // Test different order (should still match)
  assert.equal(
    variablesMatch(['measurement', 'units'], ['units', 'measurement']),
    true,
  );

  // Test different variable names
  assert.equal(variablesMatch(['measurement'], ['medición']), false);

  // Test different counts
  assert.equal(
    variablesMatch(['measurement', 'units'], ['measurement']),
    false,
  );

  // Test with duplicates
  assert.equal(variablesMatch(['units', 'units'], ['units', 'units']), true);

  // Test empty arrays
  assert.equal(variablesMatch([], []), true);

  console.log('✓ variablesMatch tests passed');
}

// Test validateTranslation
function testValidateTranslation() {
  console.log('Testing validateTranslation...');

  // Test case from the requirements
  const englishFlat = {
    'general.measurements': '{{measurement}}{{units}} (in {{units}})',
  };

  const spanishFlat = {
    'general.measurements': '{{medición}}{{unidades}} (en {{unidades}})',
  };

  const result = validateTranslation(englishFlat, spanishFlat, 'es');

  assert.equal(result.language, 'es');
  assert.equal(result.mismatches.length, 1);
  assert.equal(result.mismatches[0].key, 'general.measurements');
  assert.deepEqual(result.mismatches[0].englishVars, [
    'measurement',
    'units',
    'units',
  ]);
  assert.deepEqual(result.mismatches[0].translationVars, [
    'medición',
    'unidades',
    'unidades',
  ]);

  // Test with matching variables
  const correctSpanishFlat = {
    'general.measurements': '{{measurement}}{{units}} (en {{units}})',
  };

  const correctResult = validateTranslation(
    englishFlat,
    correctSpanishFlat,
    'es',
  );
  assert.equal(correctResult.mismatches.length, 0);

  // Test with missing key in translation (should skip)
  const incompleteSpanishFlat = {};
  const incompleteResult = validateTranslation(
    englishFlat,
    incompleteSpanishFlat,
    'es',
  );
  assert.equal(incompleteResult.mismatches.length, 0);

  // Test with extra variable in translation
  const extraVarSpanishFlat = {
    'general.measurements': '{{measurement}}{{units}}{{extra}} (in {{units}})',
  };
  const extraVarResult = validateTranslation(
    englishFlat,
    extraVarSpanishFlat,
    'es',
  );
  assert.equal(extraVarResult.mismatches.length, 1);

  // Test with missing variable in translation
  const missingVarSpanishFlat = {
    'general.measurements': '{{measurement}} (in {{units}})',
  };
  const missingVarResult = validateTranslation(
    englishFlat,
    missingVarSpanishFlat,
    'es',
  );
  assert.equal(missingVarResult.mismatches.length, 1);

  console.log('✓ validateTranslation tests passed');
}

// Test formatValidationResult
function testFormatValidationResult() {
  console.log('Testing formatValidationResult...');

  // Test with mismatches (example from requirements)
  const resultWithMismatches = {
    language: 'es',
    mismatches: [
      {
        key: 'general.measurements',
        englishVars: ['measurement', 'units', 'units'],
        translationVars: ['medición', 'unidades', 'unidades'],
      },
    ],
  };

  const formatted = formatValidationResult(resultWithMismatches);
  assert.equal(
    formatted,
    `----- es -----
"general.measurements": {{measurement}}, {{units}}, {{units}} <--> {{medición}}, {{unidades}}, {{unidades}}`,
  );

  // Test with no mismatches
  const resultNoMismatches = {
    language: 'fr',
    mismatches: [],
  };

  const formattedNoMismatches = formatValidationResult(resultNoMismatches);
  assert.equal(formattedNoMismatches, `----- fr -----\nNo mismatches found.`);

  // Test with multiple mismatches
  const resultMultipleMismatches = {
    language: 'uk',
    mismatches: [
      {
        key: 'key1',
        englishVars: ['var1'],
        translationVars: ['var1_uk'],
      },
      {
        key: 'key2',
        englishVars: ['var2', 'var3'],
        translationVars: ['var2'],
      },
    ],
  };

  const formattedMultiple = formatValidationResult(resultMultipleMismatches);
  assert.equal(
    formattedMultiple,
    `----- uk -----
"key1": {{var1}} <--> {{var1_uk}}
"key2": {{var2}}, {{var3}} <--> {{var2}}`,
  );

  console.log('✓ formatValidationResult tests passed');
}

// Test with nested JSON structure
function testNestedStructure() {
  console.log('Testing with nested JSON structure...');

  const englishJson = {
    general: {
      measurements: '{{measurement}}{{units}} (in {{units}})',
      greeting: 'Hello {{name}}',
    },
    errors: {
      notFound: 'Item {{id}} not found',
    },
  };

  const spanishJson = {
    general: {
      measurements: '{{medición}}{{unidades}} (en {{unidades}})',
      greeting: 'Hola {{name}}',
    },
    errors: {
      notFound: 'Artículo {{id}} no encontrado',
    },
  };

  const englishFlat = flatten(englishJson);
  const spanishFlat = flatten(spanishJson);

  const result = validateTranslation(englishFlat, spanishFlat, 'es');

  // Should find one mismatch (general.measurements)
  assert.equal(result.mismatches.length, 1);
  assert.equal(result.mismatches[0].key, 'general.measurements');

  console.log('✓ Nested structure tests passed');
}

// Run all tests
function runAllTests() {
  console.log('Running all tests...\n');

  testExtractVariables();
  testVariablesMatch();
  testValidateTranslation();
  testFormatValidationResult();
  testNestedStructure();

  console.log('\n✅ All tests passed!');
}

runAllTests();
